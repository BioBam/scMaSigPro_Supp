---
title: "Compression Strategy Along Time Series"

subtitle: "ScMaSigPro Supplementary Material-I"

author: "Priyansh Srivastava, ... Ana Conesa"

date: "`r Sys.Date()`"

knit: (function(inputFile, encoding) {
     rmarkdown::render(inputFile, encoding=encoding,
     output_file=file.path("../Supplementary_Material/01_Compression_Strategy.pdf"))})
     
output:
 pdf_document:
     latex_engine: lualatex

header-includes:
  - "\\usepackage{fontspec}"
  - "\\setmainfont{TeX Gyre Termes}"
---

## Required Library
```{r,"Load Library", message=FALSE, echo=FALSE, eval=TRUE}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(kableExtra))
```

## Define some custom functions
```{r,"Define custom function", message=FALSE, echo=TRUE, eval=TRUE}
# Define a function 'create_random_repeated_vector'
create_random_repeated_vector <- function(start, end, min_repetitions, max_repetitions) {
  repetitions <- sample(min_repetitions:max_repetitions,
    size = end - start + 1, replace = TRUE
  )
  result_vector <- rep(seq(from = start, to = end, by = 1),
    times = repetitions
  )
  return(result_vector)
}

# Define a function 'discretize'
discretize <- function(x, numBins, r = range(x)) {
  b <- seq(from = r[1], to = r[2], length.out = numBins + 1)
  cut_x <- cut(x, breaks = b, include.lowest = TRUE)
  y <- table(cut_x)
  return(y)
}

# Define a function 'create_range'
create_range <- function(x) {
  y <- as.character(x[["bin"]])
  y <- y %>% stringr::str_remove_all(pattern = "\\[|\\]|\\(|\\)")
  y1 <- as.numeric(sapply(strsplit(y, ","), "[", 1))
  y2 <- as.numeric(sapply(strsplit(y, ","), "[", 2))
  rangeVec <- c(y1, y2, x[["bin_size"]], x[["customTime"]])
  return(as.numeric(rangeVec))
}
```

## Create Sample Data
```{r,"Create a short time-series", message=FALSE, echo=TRUE, eval=TRUE}
# Short Pseudotime with repetitions
short.rep.pseudotime <- data.frame(
  real_pseudotime = create_random_repeated_vector(1, 100, 1, 3)
)
hist(short.rep.pseudotime$real_pseudotime)
```

---

## Sturges Binning

### Step-0: Get the time-series
```{r,"Get the time-series", message=FALSE, echo=TRUE, eval=TRUE}
time_series <- short.rep.pseudotime$real_pseudotime
head(time_series)
```

### Step-1: Calculate the number of time-points
```{r,"Calculate the number of time-", message=FALSE, echo=TRUE, eval=TRUE}
time_points <- length(time_series)
time_points
```

### Step-2: Take the log2 of the length
```{r,"Take the log2", message=FALSE, echo=TRUE, eval=TRUE}
estBins <- log2(time_points) + 1
estBins
```

### Step-3: Multiply with drop-factor to further reduce the bin-size
```{r,"Multiply with drop-factor", message=FALSE, echo=TRUE, eval=TRUE}
estBins <- estBins * 0.7 # drop.fac
estBins
```

### Step-4: Calculate Bin intervals
```{r,"Calculate Bin intervals", message=FALSE, echo=TRUE, eval=TRUE}
bin_intervals <- as.data.frame(discretize(time_series,
  numBins = estBins,
  r = range(time_series)
))
kable(bin_intervals)
```

### Step-5: Clean the table before merge
```{r,"Clean the table before merge", message=FALSE, echo=TRUE, eval=TRUE}
colnames(bin_intervals) <- c("bin", "bin_size")
bin_intervals$customTime <- rownames(bin_intervals)
kable(bin_intervals)
```

### Step-6: Create the bin table
```{r,"Create the bin table", message=FALSE, echo=TRUE, eval=TRUE}
bin_table <- as.data.frame(t(as.data.frame(apply(bin_intervals, 1, create_range))))
colnames(bin_table) <- c("from", "to", "bin_size", "binnedTime")
kable(bin_table)
```

### Step-7: Merge with Original time-series
```{r,"Merge with Original time-series", message=FALSE, echo=TRUE, eval=TRUE}
short.rep.pseudotime.pooled <- as.data.frame(
  left_join(
    short.rep.pseudotime, bin_table,
    by = join_by(
      closest(real_pseudotime >= from),
      closest(real_pseudotime <= to)
    )
  )
)
kable(short.rep.pseudotime.pooled[c(c(1:3), c(29:33), c(55:58)), ])
```



